---
title: 多叉树和B+树
date: 2025-11-16 22:54:00 +0800
description: 
categories:
  - 数据结构
  - 课程笔记
tags:
  - 数据结构
  - 多叉树
math: true
---

学习完二叉树和二分搜索树之后我们可以再来看看三叉树是怎么实现的，随后可以推广到多叉树。
#### 三叉树
三叉树的一个节点需要**两个值和三个指针**，以及一个 `int num_values (1 or 2)` 来存储当前节点有几个值（还有几个空位）。

![三叉树一个节点](resources/多叉树和B+树/三叉树一个节点.png)

这是因为为了实现三叉树，必须要有两个可进行比较的元素来将当前进入的节点划分到两个值切成的三个范围中（也就是三个指针指向左、中、右子树）。

![三叉树数据构成](resources/多叉树和B+树/三叉树数据构成.png)

和二叉树的本质是一样的（一个值分出两个区域）。

更多三叉树的操作不一一列举，可自行查找资料和看 *P7-10* 

关于三叉树的 `insert` 操作和上面讲的并无差别，简单来说就是：*P11* 
- 先尝试进入当前节点中，并按照值的大小来进行排列；
- 节点若满，则和节点中的两个值进行比较并前往左、中、右子树；

#### 三叉树中序遍历（In-order Traversal）
关于中序遍历，可以先看看**二叉树的中序遍历**，在Leetcode上有[这么一题](https://leetcode.cn/problems/binary-tree-inorder-traversal/)。
二叉树的中序遍历就是按照左子树，右子树来进行递归遍历。

三叉树中序遍历的具体实现：

```cpp
template <typename Type>
void Three_way_node<Type>::in_order_traversal() const {

    if (!full()) {
        cout << first();
    } else {
        if (left() != nullptr) {
            left()->in_order_traversal();
        }
        cout << first();
        if (middle() != nullptr) {
            middle()->in_order_traversal();
        }
        cout << second();
        if (right() != nullptr) {
            right()->in_order_traversal();
        }
    }
}
```

![](resources/多叉树和B+树/三叉树中序遍历.png)

我们当然可以拓展到N叉树（N-ary Tree）的中序遍历，代码实现也是一样的思路，我们可以使用一个循环来进行中间多个值的中序遍历操作：

```cpp
template <typename Type, int N>
void Multivay_node<Type, N>::in_order_traversal() const {
    if (empty()) {
        return;
    } else if (!full()) {
        for (int i = 0; i < num_values; ++i) {
            cout << elements[i];
        }
    } else {
        for (int i = 0; i < N - 1; ++i) {
            if (subtrees[i] != nullptr) {
                subtrees[i]->in_order_traversal();
            }
            cout << elements[i];
        }
        if (subtrees[N - 1] != nullptr) {
            subtrees[N - 1]->in_order_traversal();
        }
        
        subtrees[N - 1]->in_order_traversal();
    }
}
```

To be continue...