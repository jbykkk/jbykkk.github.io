---
title: "二分搜索树和AVL树"
date: 2025-10-13 22:51:00 +0800  
categories: [数据结构, 课程笔记]
tags: [数据结构, 树结构]
math: true
---

## 二分查找树（Binary Search Tree）

相比于二叉树有更加严格的性质

- 无重复元素
- 从左到右、从上到下依次增大

### 寻找操作（Find）

**核心想法是一直比较左右节点，然后向下查找，或赋值或递归** 
- 找最小
```cpp
BinaryNode<Comparable>* findMin(BinaryNode<Comparable>* t) const {
    if (t == nullptr)
        return nullptr;
    if (t->left == nullptr)
        return t;
    return findMin(t->left);
}
```
- 找最大
- 找任意一个
```cpp
bool contains(const Comparable& x, BinaryNode<Comparable>* t) const
{
    if (t == nullptr) return false;
    else if (x < t->element)
        return contains(x, t->left);
    else if (t->element < x)
        return contains(x, t->right);
    else
        return true;
}
```
时间复杂度都是 $O(h)$ 。

### 插入（Insert）

**插入节点只插在叶子节点后** 
```cpp
void insert(const Comparable& x, BinaryNode<Comparable>*& t) { if (t == nullptr) t = new BinaryNode<Comparable>(x, nullptr, nullptr); else if (x < t->element) insert(x, t->left); else if (t->element < x) insert(x, t->right); else ; }
```

### 移除（Erase）

分为三种情况：
- 叶子节点
	`delete` 然后其父节点的相应子节点设为 `nullptr`  
- 该节点有一个子节点
	子节点接到父节点，删除该节点
- 该节点有两个子节点（Full Node）
	选左子树最大/右子树最小，替换该节点，删除该节点（可能会用到前两种情况）

要对原树进行操作，需要传入引用
```cpp
void remove(const Comparable& x, BinaryNode<Comparable>*& t) {
    if (t == nullptr)
        return; // Item not found; do nothing
    if (x < t->element)
        remove(x, t->left);
    else if (t->element < x)
        remove(x, t->right);
    else if (t->left != nullptr && t->right != nullptr) // Two children
    {
        t->element = findMin(t->right)->element;
        remove(t->element, t->right);
    }
    else
    {
        BinaryNode<Comparable>* oldNode = t;
        t = (t->left != nullptr) ? t->left : t->right;
        delete oldNode;
    }
}
```

### 前一个小的/后一个大的（Previous Smaller/Next largest）

？待补充

**时间复杂度分析**

- 最坏的情况是 $O(n)$ ,这个BST变成一个链表
- 最好的情况，PerfectBST，$O(ln(n))$ 
- 我们的目标是让这个树的高度维持在 $\Theta(ln(n))$ 

一个随机生成的二叉搜索树的平均高度实际上是 $\Theta(\ln(n))$ ；但是在随机插入和删除之后，平均高度倾向于增加到 $\Theta(\sqrt{n})$。

那么如果我们希望能保持比较好的情况的话，我们需要让这棵树满足一定的性质，
这棵树需要是**平衡的（Height Balanced）**，事实上一棵树的平衡属性有很多，可以是权重平衡，也可以是高度平衡，为了实现我们上述的要求，需要的应该是能实现高度（深度 Depth）平衡的。

**AVL Tree** 
AVL Tree 是实现高度平衡的良好实践，
**平衡**的概念：任意一节点的左右子树高度差 $\leq 1$ 

首先我们来考虑一种最简单的不平衡的情况，*P90-P96* 这三个节点如何将不平衡调整为平衡是后续更加复杂的平衡性修正的基石。

具体步骤：
- 先判断哪个节点是发生不平衡的地方，注意这个不平衡子树的路径；
- 从这个不平衡的点**沿路径向下构建**前面说的三个点的最简单情况
- 判断这个不平衡的类型是什么样的，具体有：
	- `LLL`（*P134* ）
	- ![[情况1.png]]
	- `LLR`（*P144* ）
	- ![[情况2.png]]
- 修复（**可能需要多次**）

至于 `RRR` 和 `RRL` 另外两种，只是上面两种的镜像形式，操作都是一样的。

不平衡的情况通常发生在 `insert` 和 `erase` 操作时，因此若在一个平衡的树种进行插入则必须要判断并修复；一般来说，`insert` 至少都要一次修复，而`erase`可能需要 $O(h)$ 次修复。