---
title: "堆和堆排序"
date: 2025-11-04 11:09:00 +0800  
categories: [数据结构, 课程笔记]
tags: [数据结构, 排序算法]
math: true
---

## 排序算法笔记：选择排序 vs. 插入排序

### 1. 选择排序 (Selection Sort)

#### 核心思想
每一轮在**未排序**的部分中，扫描并找到**全局最小**的元素，然后将其与未排序部分的**第一个元素**交换。

#### C++ 代码实现
```cpp
template <typename Type>
void selection_sort( Type *const array, int const n ) {
  for ( int i = 0; i < n - 1; i++ ) {
    // 在未排序部分 array[i]...array[n-1] 中找到最小值
    int lowindex = i;
    for ( int j = n - 1; j > i; j-- ) {
      if ( array[j] < array[lowindex] ) {
        lowindex = j;
      }
    }
    // 将找到的最小值与未排序部分的开头交换
    Type temp = array[i];
    array[i] = array[lowindex];
    array[lowindex] = temp;
  }
}
```

#### 关键点分析

*   **边界控制**:
    *   外层循环 `i < n - 1`：当只剩最后一个元素时，它自然有序，无需再循环，这是一个正确的优化。
    *   内层循环 `j > i`：确保了查找范围是 `i` 之后的所有元素，并且与 `lowindex = i` 的初始化配合得很好。
*   **核心问题澄清：与谁交换？**
    *   **错误理解**：与已排序部分的最后一个元素 (`array[i-1]`) 交换。
    *   **正确理解**：与**未排序部分**的**第一个元素** (`array[i]`) 交换。`i` 是本轮要被填充的“坑位”。
*   **更精确的视角：三段论**
    *   在 `i` 轮循环中，数组可看作：
        1.  `array[0...i-1]`: **已排序区**
        2.  `array[i]`: **当前坑位** (也是临时的最小值候选)
        3.  `array[i+1...n-1]`: **搜索区** (在此寻找真正的最小值)

---

### 2. 插入排序 (Insertion Sort)

#### 核心思想
像整理扑克牌一样，每次从**未排序**部分取第一个元素，然后在**已排序**部分中从后往前扫描，找到正确的位置并**插入**。

#### C++ 代码实现
```cpp
template <typename Type>
void insertion_sort( Type *const array, int const n ) {
  for ( int k = 1; k < n; ++k ) {
    for ( int j = k; j > 0; --j ) {
      if ( array[j - 1] > array[j] ) {
        std::swap( array[j - 1], array[j] );
      } else {
        // 优化点：一旦无需交换，说明已找到位置
        break;
      }
    }
  }
}
```
#### 关键点分析
*   **边界控制**:
    *   外层循环 `k = 1`：从第二个元素开始，因为单个元素 (`array[0]`) 默认已排序。
    *   内层循环 `j > 0`：防止 `array[j-1]` 访问到负数索引，保证了比较的安全性。
*   **`break` 优化**:
    *   这是插入排序的精髓。因为 `array[0...k-1]` 是**有序的**，所以当 `array[j]` 向前移动时，一旦遇到一个比它小的元素 `array[j-1]`，就意味着它已到达正确位置，无需再往前比较。
    *   这个特性使得插入排序在处理**近乎有序**的数组时效率极高。

---

### 3. 核心区别对比

#### 性能特点对比

| 特性 | **选择排序 (Selection Sort)** | **插入排序 (Insertion Sort)** |
| :--- | :--- | :--- |
| **核心操作** | 找最小 & 交换到头部 | 逐个向前比较 & 交换/插入 |
| **数据移动(Swaps)** | **少**，`O(n)` 次 | **多**，最差 `O(n²)` 次 |
| **比较次数** | **固定**，`O(n²)` 次 | **不固定**，取决于有序度 |
| **稳定性** | **不稳定** | **稳定** |
| **自适应性** | **否** (对有序数组不敏感) | **是** (对有序数组性能极好) |

#### 时间复杂度对比

| 时间复杂度 | **选择排序 (Selection Sort)** | **插入排序 (Insertion Sort)** |
| :--- | :--- | :--- |
| **最佳情况** | **`O(n²)`** (数组已有序) | **`O(n)`** (数组已有序) |
| **平均情况** | **`O(n²)`** | **`O(n²)`** |
| **最差情况** | **`O(n²)`** (数组逆序) | **`O(n²)`** (数组逆序) |

### 总结

*   **选择排序** 无论输入如何，性能都稳定在 `O(n²)`，它的唯一优势是**交换次数少**。
*   **插入排序** 性能更优，尤其在处理**小规模**或**近乎有序**的数据时表现出色，是更实用的简单排序算法。

---

### 插入排序笔记：移位实现 vs. 交换实现

### 插入排序（移位式实现）

这是对插入排序的一种常见优化，通过减少数据赋值次数来提升性能。

#### 核心思想
**“保存并移位，最后一次性插入”**。

1.  **保存**：将待排序元素 `array[k]` 存入临时变量 `tmp`，在原位置形成一个“空位”。
2.  **移位**：从后向前比较已排序序列，将所有大于 `tmp` 的元素逐一向右移动一格。
3.  **插入**：当移位结束后，“空位”所在的位置就是 `tmp` 的最终归宿，将其放入即可。

#### C++ 代码实现 (本次分析的版本)
```cpp
template <typename Type>
void insertion( Type *const array, int const n ) {
  for ( int k = 1; k < n; ++k ) {
    Type tmp = array[k]; // 1. 保存元素，形成“空位”

    // 2. 移位过程
    for ( int j = k; j > 0; --j ) {
      if ( array[j - 1] > tmp ) {
        array[j] = array[j - 1]; // 将大元素右移
      } else {
        array[j] = tmp; // 3. 找到位置，插入
        break;
      }
    }

    // 4. 特殊情况处理：如果tmp是最小元素
    if ( array[0] > tmp ) {
      array[0] = tmp;
    }
  }
}
```

### 关键细节与特殊性分析

1.  **性能优势**：
    *   **交换式**：一次交换 (`std::swap`) 包含 **3 次**赋值操作。
    *   **移位式**：一次移位 (`array[j] = array[j-1]`) 只包含 **1 次**赋值操作。
    *   因此，在元素需要移动多步时，移位式的赋值总次数远少于交换式，效率更高。

2.  **代码结构的特殊性（本次分析版本）**：
    *   **插入逻辑的分离**：这份代码的插入操作被拆分到了两个地方：
        *   `else` 块内的 `array[j] = tmp;`：处理 `tmp` 插入到数组 `1` 到 `k` 之间位置的情况。
        *   循环外的 `if (array[0] > tmp)`：专门处理 `tmp` 需要插入到数组最开头 (`位置0`) 的情况。
    *   **为何需要末尾的 `if`**：当 `tmp` 是当前最小元素时，内层 `for` 循环会一直执行移位操作直到循环条件 `j > 0` 不满足而终止。在这个过程中，`else` 块永远不会被触发，导致 `tmp` 没有被放回数组。因此，循环外的 `if` 语句是必需的“补丁”，用于完成这最后一步的插入。

### 与“交换式”插入排序的核心区别

| 特性 | 交换式插入排序 (Swap Version) | 移位式插入排序 (Shift Version) |
| :--- | :--- | :--- |
| **核心操作** | `std::swap` | 赋值（移位） |
| **数据移动** | 每次移动都涉及 3 次赋值。 | 每次移动只涉及 1 次赋值，最后再加 1 次插入。 |
| **代码逻辑** | 逻辑统一，每次比较后要么交换要么终止。 | **更优**，但本次分析的代码将插入逻辑拆分，略显复杂。 |
| **性能** | 相对较低。 | **相对更高**，是插入排序的推荐实现方式。 |

### 总结
“移位式”插入排序是标准插入排序的优化版本，通过将多次交换操作替换为一次性的元素保存和多次移位，显著减少了数据赋值的开销。本次分析的代码虽然功能正确，但其将插入逻辑拆分到循环内外两处的结构较为特殊，理解其末尾 `if` 语句的“补丁”作用是掌握该实现的关健。